<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Big Five(OCEAN) 성격 스펙트럼 분석 — IPIP-50 기반 (오프라인/단일 HTML)</title>
  <style>
    :root{
      --bg:#0b0e14;
      --panel:#111827;
      --panel2:#0f172a;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --line:#24324a;
      --accent:#60a5fa;
      --danger:#fb7185;
      --ok:#34d399;
      --warn:#fbbf24;
      --shadow: 0 8px 24px rgba(0,0,0,.35);
      --radius: 14px;
      --maxw: 1050px;
    }
    html,body{height:100%;}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif;
      background: radial-gradient(1200px 900px at 20% 0%, #111827 0%, var(--bg) 60%);
      color:var(--text);
      line-height:1.55;
    }
    a{color:var(--accent); text-decoration:none;}
    a:hover{text-decoration:underline;}
    .wrap{max-width:var(--maxw); margin:0 auto; padding:28px 16px 64px;}
    header{
      background: linear-gradient(120deg, rgba(96,165,250,.18), rgba(52,211,153,.10));
      border: 1px solid rgba(96,165,250,.18);
      border-radius: var(--radius);
      padding: 18px 18px 16px;
      box-shadow: var(--shadow);
    }
    header h1{margin:0 0 8px; font-size:20px; letter-spacing:.2px;}
    header p{margin:6px 0; color:var(--muted); font-size:13px;}
    .grid{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:14px;
      margin-top:14px;
    }
    @media (max-width: 920px){
      .grid{grid-template-columns:1fr;}
    }
    .card{
      background: rgba(17,24,39,.72);
      border: 1px solid rgba(36,50,74,.9);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .card h2{margin:0 0 8px; font-size:15px;}
    .card h3{margin:14px 0 6px; font-size:13px; color:#d1d5db;}
    .muted{color:var(--muted);}
    .tiny{font-size:12px;}
    .pill{
      display:inline-flex; align-items:center;
      padding:2px 10px;
      border-radius:999px;
      border:1px solid rgba(96,165,250,.28);
      background: rgba(96,165,250,.10);
      font-size:12px;
      color:#dbeafe;
      margin-right:6px;
      margin-bottom:6px;
      user-select:none;
    }
    .pill.warn{border-color: rgba(251,191,36,.35); background: rgba(251,191,36,.12); color:#fde68a;}
    .pill.ok{border-color: rgba(52,211,153,.35); background: rgba(52,211,153,.12); color:#d1fae5;}
    .pill.bad{border-color: rgba(251,113,133,.35); background: rgba(251,113,133,.12); color:#fecdd3;}
    .controls{
      display:flex;
      flex-wrap:wrap;
      gap:10px 12px;
      align-items:center;
      margin-top:10px;
    }
    .controls label{
      display:flex; align-items:center; gap:8px;
      font-size:13px; color:#d1d5db;
      user-select:none;
    }
    input[type="checkbox"]{transform: translateY(1px);}
    button{
      background: rgba(96,165,250,.20);
      border: 1px solid rgba(96,165,250,.35);
      color: #e5e7eb;
      padding: 10px 12px;
      border-radius: 12px;
      cursor:pointer;
      font-weight:600;
      letter-spacing:.1px;
    }
    button:hover{filter:brightness(1.08);}
    button.secondary{
      background: rgba(156,163,175,.12);
      border: 1px solid rgba(156,163,175,.28);
    }
    button.danger{
      background: rgba(251,113,133,.14);
      border: 1px solid rgba(251,113,133,.35);
    }
    button:disabled{
      opacity:.55; cursor:not-allowed;
    }
    .progress{
      position: sticky;
      top: 12px;
      z-index: 5;
      margin-top: 12px;
      background: rgba(17,24,39,.85);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(36,50,74,.9);
      border-radius: var(--radius);
      padding: 10px 12px;
      box-shadow: var(--shadow);
    }
    .bar{
      height:10px;
      border-radius:999px;
      background: rgba(36,50,74,.8);
      overflow:hidden;
      border: 1px solid rgba(36,50,74,1);
    }
    .bar > div{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, rgba(96,165,250,.8), rgba(52,211,153,.8));
      transition: width .25s ease;
    }
    .progline{display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:8px;}
    .progline .pct{font-variant-numeric: tabular-nums;}
    .items{margin-top:12px;}
    .item{
      border: 1px solid rgba(36,50,74,.9);
      background: rgba(15,23,42,.62);
      border-radius: 14px;
      padding: 12px;
      margin-bottom:10px;
    }
    .item .stem{font-size:14px; margin-bottom:10px;}
    .item .stem small{display:block; margin-top:4px; color:var(--muted); font-size:12px;}
    .scale{
      display:grid;
      grid-template-columns: repeat(5, minmax(0,1fr));
      gap:8px;
      align-items:stretch;
    }
    .opt{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:6px;
      padding: 8px 8px;
      border-radius: 10px;
      border: 1px solid rgba(36,50,74,.9);
      background: rgba(17,24,39,.55);
      cursor:pointer;
      user-select:none;
      font-size:12px;
      text-align:center;
      min-height: 38px;
    }
    .opt:hover{border-color: rgba(96,165,250,.45);}
    .opt input{display:none;}
    .opt.selected{
      border-color: rgba(96,165,250,.70);
      background: rgba(96,165,250,.18);
    }
    .legend{
      display:flex; gap:8px; flex-wrap:wrap; margin-top:8px;
      color:var(--muted); font-size:12px;
    }
    .legend span{padding:2px 8px; border:1px solid rgba(36,50,74,.9); border-radius:999px; background: rgba(17,24,39,.55);}
    .results{margin-top:14px;}
    .hidden{display:none !important;}
    .resultGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
      margin-top:12px;
    }
    @media (max-width: 920px){
      .resultGrid{grid-template-columns:1fr;}
    }
    .scoreCards{
      display:grid;
      grid-template-columns: repeat(5, minmax(0,1fr));
      gap:10px;
    }
    @media (max-width: 920px){
      .scoreCards{grid-template-columns: repeat(2, minmax(0,1fr));}
    }
    .scoreCard{
      border:1px solid rgba(36,50,74,.9);
      border-radius: 14px;
      background: rgba(15,23,42,.62);
      padding:10px;
    }
    .scoreCard .t{font-size:12px; color:var(--muted); margin:0 0 2px;}
    .scoreCard .v{font-size:20px; margin:0; font-variant-numeric: tabular-nums;}
    .scoreCard .s{font-size:12px; color:#d1d5db; margin-top:2px;}
    .hbar{
      margin-top:8px;
      height: 10px;
      border-radius: 999px;
      background: rgba(36,50,74,.8);
      overflow:hidden;
      border: 1px solid rgba(36,50,74,1);
    }
    .hbar > div{height:100%; width:0%; background: rgba(96,165,250,.75); transition: width .35s ease;}
    .chartWrap{display:flex; justify-content:center; align-items:center; padding: 10px 0;}
    canvas{max-width:100%; height:auto;}
    details{
      border:1px solid rgba(36,50,74,.9);
      background: rgba(15,23,42,.62);
      border-radius: 14px;
      padding: 10px 12px;
      margin-top:10px;
    }
    summary{
      cursor:pointer;
      font-weight:700;
      color:#e5e7eb;
    }
    summary small{font-weight:500; color:var(--muted);}
    .kvs{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 920px){ .kvs{grid-template-columns:1fr;} }
    .kv{
      border:1px dashed rgba(36,50,74,.9);
      border-radius: 12px;
      padding: 10px;
      background: rgba(17,24,39,.35);
    }
    .kv b{display:block; margin-bottom:6px;}
    .warnBox{
      border:1px solid rgba(251,191,36,.35);
      background: rgba(251,191,36,.08);
      border-radius: 14px;
      padding: 10px 12px;
      margin-top: 10px;
    }
    .warnBox b{color:#fde68a;}
    .okBox{
      border:1px solid rgba(52,211,153,.35);
      background: rgba(52,211,153,.08);
      border-radius: 14px;
      padding: 10px 12px;
      margin-top: 10px;
    }
    .okBox b{color:#d1fae5;}
    .tableWrap{overflow:auto; margin-top:10px; border-radius: 12px;}
    table{
      width:100%;
      border-collapse: collapse;
      min-width: 740px;
      font-size:12px;
    }
    th,td{
      border-bottom:1px solid rgba(36,50,74,.9);
      padding:8px 8px;
      vertical-align:top;
    }
    th{
      text-align:left;
      position:sticky;
      top:0;
      background: rgba(17,24,39,.95);
      backdrop-filter: blur(6px);
      z-index:2;
    }
    code.inline{
      background: rgba(17,24,39,.65);
      border:1px solid rgba(36,50,74,.9);
      padding:2px 6px;
      border-radius: 8px;
      font-size: 12px;
    }
    .footer{
      margin-top:14px;
      padding-top:10px;
      border-top: 1px solid rgba(36,50,74,.9);
      color: var(--muted);
      font-size: 12px;
    }
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
    .sr-only{position:absolute;left:-9999px;}
    .tagrow{margin-top:8px;}
    .tagrow .pill{margin-right:6px;}
    .note{
      border:1px solid rgba(96,165,250,.30);
      background: rgba(96,165,250,.08);
      border-radius: 14px;
      padding: 10px 12px;
      margin-top: 10px;
    }
    .note b{color:#dbeafe;}
    .split{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    @media (max-width: 920px){
      .split{grid-template-columns:1fr;}
    }
    .field{
      display:flex; flex-direction:column; gap:6px;
      margin-top:8px;
    }
    .field label{font-size:12px; color:var(--muted);}
    .field input{
      padding:10px 10px;
      border-radius: 12px;
      border:1px solid rgba(36,50,74,.9);
      background: rgba(17,24,39,.55);
      color: var(--text);
      outline:none;
    }
    .field input:focus{border-color: rgba(96,165,250,.65);}
    .smallbtns{display:flex; flex-wrap:wrap; gap:8px; margin-top:10px;}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Big Five(OCEAN) 성격 스펙트럼 분석 — IPIP-50 기반 (단일 HTML · 오프라인 실행)</h1>
      <p class="tiny">
        이 파일은 <b>외부 라이브러리/서버 없이</b> 브라우저에서 즉시 실행됩니다. 응답은 어디에도 전송되지 않습니다(로컬에서만 계산).
      </p>
      <p class="tiny">
        사용 문항: <span class="pill">IPIP Big-Five Factor Markers (50 items)</span>
        <span class="pill ok">Public Domain</span>
        <span class="pill warn">의학/진단 도구 아님</span>
      </p>
      <p class="tiny muted">
        참고: IPIP는 “유형”으로 사람을 박제하지 말고, <b>연속 스펙트럼</b>으로 해석하라고 권고합니다. (이 앱도 그 방식 그대로 갑니다.)
      </p>
    </header>

    <div class="grid">
      <section class="card">
        <h2>1) 큰그림 (왕초보용)</h2>
        <p>
          Big Five(=OCEAN)는 사람 성격을 <b>5개의 독립 축</b>으로 본다. “당신은 A형 인간” 같은 단일 유형 딱지 붙이는 게 아니라,
          <b>5개의 슬라이더(스펙트럼)</b>가 각각 어디쯤 있는지 보는 모델이다.
        </p>
        <div class="note tiny">
          <b>비유 1)</b> 성격은 “혈액형”이 아니라 <b>이퀄라이저(음향 조절기)</b>다. 베이스/미들/트레블처럼 5개 손잡이가 따로 움직인다.<br/>
          <b>비유 2)</b> “자동차 세팅”이다. 서스펜션(정서 안정), 연비모드(성실성)처럼 항목별 셋업이 다르다.<br/>
          <b>비유 3)</b> “게임 스탯”이다. 힘/민첩/지능을 합쳐서 한 타입으로 뭉개는 게 아니라 각 스탯을 따로 본다.
        </div>

        <h3>그럼 이건 뭐야? (짧은 Q&A)</h3>
        <p class="tiny"><b>Q.</b> “내 성격이 몇 점” 같은 거임?<br/>
          <b>A.</b> 한 줄로 말하면 <b>다섯 축 각각 점수</b>. 합산해서 “총점으로 인간 등급” 매기는 건 아니다.
        </p>
        <p class="tiny"><b>Q.</b> 임상에서 쓰는 거라며? 그럼 진단 가능?<br/>
          <b>A.</b> 아니. 이건 <b>성격 특질(trait)</b> 측정이지, 질병 진단 도구가 아니다. 상담/임상에서는 다른 정보(면담, 관찰, 병력 등)랑 같이 본다.
        </p>

        <h2>2) 응답 규칙</h2>
        <p class="tiny muted">
          각 문장에 대해 “나랑 얼마나 맞는지”를 1~5로 체크하세요. 정답 없음. 속도전도 금지. “평소의 나”로 답하는 게 가장 낫습니다.
        </p>

        <div class="controls">
          <label><input type="checkbox" id="toggleEnglish" checked /> 문항에 영어 원문도 함께 표시</label>
          <label><input type="checkbox" id="shuffleItems" /> 문항 순서 섞기(권장)</label>
          <label><input type="checkbox" id="requireAll" checked /> 미응답 있으면 결과 계산 막기</label>
        </div>

        <div class="legend">
          <span>1 매우 아니다</span>
          <span>2 약간 아니다</span>
          <span>3 중간</span>
          <span>4 약간 그렇다</span>
          <span>5 매우 그렇다</span>
        </div>

        <div class="progress" id="progressBox">
          <div class="progline">
            <div class="tiny muted">진행률</div>
            <div class="tiny pct mono" id="progressText">0 / 50 (0%)</div>
          </div>
          <div class="bar" aria-hidden="true"><div id="progressBar"></div></div>
        </div>

        <div class="items" id="items"></div>

        <div class="controls">
          <button id="btnScore">결과 계산</button>
          <button class="secondary" id="btnReset">전체 초기화</button>
        </div>
        <p class="tiny muted">
          * 이 설문은 자기보고식(self-report)입니다. “내가 나를 어떻게 보는가”가 반영됩니다.
        </p>
      </section>

      <aside class="card">
        <h2>3) 결과 해석 방식(핵심개념)</h2>
        <p class="tiny">
          이 앱은 IPIP 공식 방식대로 <b>+키 문항은 그대로</b>, <b>-키(반전) 문항은 뒤집어서</b> 합산합니다.
          그리고 각 요인을 0~100 스케일로 선형 변환해 <b>직관적 그래프</b>로 보여줍니다.
        </p>
        <div class="kvs tiny">
          <div class="kv">
            <b>한 줄 정의</b>
            “점수 높다/낮다”는 <b>좋다/나쁘다</b>가 아니라, <b>어떤 경향이 더 자주/강하게 나타나는가</b>에 가깝다.
          </div>
          <div class="kv">
            <b>중요한 주의</b>
            IPIP는 “너는 외향형이다” 같은 <b>타입 딱지</b>를 경계합니다. <b>연속선(continuum)</b>으로 보세요.
          </div>
        </div>

        <h3>그럼 이건 뭐야? (짧은 Q&A)</h3>
        <p class="tiny"><b>Q.</b> 반전 문항은 왜 넣음?<br/>
          <b>A.</b> “나는 다 그렇다”처럼 무조건 동의/부정하는 습관(응답 편향)을 줄이려고.
        </p>
        <p class="tiny"><b>Q.</b> 0~100 점이면 표준점수/백분위야?<br/>
          <b>A.</b> 기본 표시는 <b>이론적 스케일</b>(1~5를 0~100으로 바꾼 것)이고,
          <b>진짜 ‘표준화(타인 대비)’</b>는 보통 성별/연령/표본 평균·표준편차가 있어야 한다.
        </p>

        <div class="warnBox tiny">
          <b>중요:</b> 이 앱은 IPIP 문항을 기반으로 한 <b>교육·자기이해용</b> 구현입니다.
          채용/진단 등 고위험 의사결정에 단독 사용하지 마세요.
        </div>

        <details>
          <summary>근거(참고문헌) 미리보기 <small>— 앱 하단에 전체 목록 있음</small></summary>
          <p class="tiny muted">
            IPIP(공개 문항/채점), Big Five 정의(APA), FFM 개요(McCrae & John), 최신 리뷰(Widiger) 등을 기반으로 해석 문구를 구성했습니다.
          </p>
        </details>

        <div class="okBox tiny">
          <b>프라이버시:</b> 네트워크 요청 없음. 로컬에서만 계산. (브라우저 개발자도구로 확인 가능)
        </div>
      </aside>
    </div>

    <section class="card results hidden" id="results">
      <h2>4) 결과</h2>
      <p class="tiny muted">
        아래 점수는 <b>연속 스펙트럼</b>입니다. “나는 O형 인간” 같은 유형 분류는 하지 않습니다.
      </p>

      <div class="scoreCards" id="scoreCards"></div>

      <div class="resultGrid">
        <div class="card" style="background: rgba(17,24,39,.45);">
          <h2>시각화</h2>
          <div class="chartWrap">
            <canvas id="radar" width="520" height="420" role="img" aria-label="Big Five 레이더 차트"></canvas>
          </div>
          <div id="bars"></div>
          <div class="smallbtns">
            <button class="secondary" id="btnDownloadJson">결과 JSON 다운로드</button>
            <button class="secondary" id="btnCopyJson">JSON 복사</button>
            <button class="secondary" id="btnDownloadPng">차트 PNG 다운로드</button>
          </div>
          <p class="tiny muted" id="timeInfo"></p>
        </div>

        <div class="card" style="background: rgba(17,24,39,.45);">
          <h2>해석</h2>
          <div id="validity"></div>

          <details open id="interpO"></details>
          <details open id="interpC"></details>
          <details open id="interpE"></details>
          <details open id="interpA"></details>
          <details open id="interpN"></details>

          <details>
            <summary>표준화(선택) — 내 표본 평균/표준편차가 있을 때만</summary>
            <p class="tiny muted">
              IPIP는 개인 점수 해석을 위해 <b>동일 집단 표본</b>의 평균/표준편차로 비교하는 방식을 권합니다.
              여기서는 원하면 직접 입력해 <b>z점수/백분위(정규분포 가정)</b>를 계산해 볼 수 있습니다.
              (입력 안 해도 됩니다.)
            </p>
            <div class="split" id="normInputs"></div>
            <div class="smallbtns">
              <button class="secondary" id="btnApplyNorms">표준화 적용</button>
              <button class="secondary" id="btnClearNorms">표준화 초기화</button>
            </div>
            <div id="normOut" class="tiny"></div>
          </details>

          <details>
            <summary>채점 상세(투명성) — 문항별 점수/반전 처리 보기</summary>
            <div class="tableWrap">
              <table>
                <thead>
                  <tr>
                    <th style="width:58px;">번호</th>
                    <th style="width:110px;">요인</th>
                    <th>문항</th>
                    <th style="width:110px;">응답</th>
                    <th style="width:110px;">반전 후</th>
                  </tr>
                </thead>
                <tbody id="scoreTableBody"></tbody>
              </table>
            </div>
          </details>
        </div>
      </div>

      <div class="footer">
        <div><b>주의(요약):</b> 이 결과는 자기보고식 특질 측정이며, 임상적 진단이나 처방을 대체하지 않습니다.</div>
        <div style="margin-top:6px;">
          <b>문항/채점 출처:</b> IPIP Big-Five Factor Markers(공개 도메인) · +키/–키 반전 채점 규칙(IPIP).
        </div>
        <div style="margin-top:6px;">
          <b>참고문헌(링크):</b>
          <ul>
            <li><a href="https://ipip.ori.org/" target="_blank" rel="noopener">IPIP 공식 사이트</a></li>
            <li><a href="https://ipip.ori.org/newBigFive5broadKey.htm" target="_blank" rel="noopener">Big-Five Factor Markers — 10-item scales(+/− keyed)</a></li>
            <li><a href="https://ipip.ori.org/newScoringInstructions.htm" target="_blank" rel="noopener">IPIP 채점 규칙(+키/−키)</a></li>
            <li><a href="https://ipip.ori.org/newPermission.htm" target="_blank" rel="noopener">IPIP 사용 권한(공개 도메인)</a></li>
            <li><a href="https://ipip.ori.org/InterpretingIndividualIPIPScaleScores.htm" target="_blank" rel="noopener">IPIP 점수 해석(연속선/표본 평균·SD 권고)</a></li>
            <li><a href="https://dictionary.apa.org/big-five-personality-model" target="_blank" rel="noopener">APA Dictionary: Big Five personality model</a></li>
            <li><a href="https://pubmed.ncbi.nlm.nih.gov/1635039/" target="_blank" rel="noopener">McCrae & John (1992): Five-Factor Model 소개</a></li>
            <li><a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC6732674/" target="_blank" rel="noopener">Widiger (2019): FFM 업데이트 리뷰</a></li>
            <li><a href="https://nobaproject.com/modules/personality-traits" target="_blank" rel="noopener">Noba Project: Personality Traits</a></li>
          </ul>
        </div>
      </div>
    </section>
  </div>

<script>
(() => {
  "use strict";

  // -----------------------------
  // Data: IPIP Big-Five Factor Markers (10-item scales)
  // Source for items and +/- keyed direction:
  // https://ipip.ori.org/newBigFive5broadKey.htm
  // -----------------------------
  const ITEMS = [
    // Extraversion (E) — 10 items (5 +, 5 -)
    {n:1, trait:"E", keyed:+1, en:"Am the life of the party.", ko:"모임에서 분위기 메이커인 편이다."},
    {n:2, trait:"E", keyed:+1, en:"Feel comfortable around people.", ko:"사람들 주변에 있으면 편안하다."},
    {n:3, trait:"E", keyed:+1, en:"Start conversations.", ko:"먼저 대화를 시작하는 편이다."},
    {n:4, trait:"E", keyed:+1, en:"Talk to a lot of different people at parties.", ko:"모임에서 여러 사람과 두루 이야기한다."},
    {n:5, trait:"E", keyed:+1, en:"Don't mind being the center of attention.", ko:"주목받는 것이 크게 신경 쓰이지 않는다."},
    {n:6, trait:"E", keyed:-1, en:"Don't talk a lot.", ko:"말이 많은 편은 아니다."},
    {n:7, trait:"E", keyed:-1, en:"Keep in the background.", ko:"뒤에서 조용히 있는 편이다."},
    {n:8, trait:"E", keyed:-1, en:"Have little to say.", ko:"할 말이 별로 없다."},
    {n:9, trait:"E", keyed:-1, en:"Don't like to draw attention to myself.", ko:"내가 주목받는 건 별로 좋아하지 않는다."},
    {n:10, trait:"E", keyed:-1, en:"Am quiet around strangers.", ko:"낯선 사람 앞에서는 조용한 편이다."},

    // Agreeableness (A) — 10 items (6 +, 4 -)
    {n:11, trait:"A", keyed:+1, en:"Am interested in people.", ko:"사람들에게 관심이 많다."},
    {n:12, trait:"A", keyed:+1, en:"Sympathize with others' feelings.", ko:"다른 사람 감정에 공감한다."},
    {n:13, trait:"A", keyed:+1, en:"Have a soft heart.", ko:"마음이 여린 편이다."},
    {n:14, trait:"A", keyed:+1, en:"Take time out for others.", ko:"다른 사람을 위해 시간을 낸다."},
    {n:15, trait:"A", keyed:+1, en:"Feel others' emotions.", ko:"다른 사람 감정을 잘 느끼는 편이다."},
    {n:16, trait:"A", keyed:+1, en:"Make people feel at ease.", ko:"사람들을 편하게 해주는 편이다."},
    {n:17, trait:"A", keyed:-1, en:"Am not really interested in others.", ko:"남에게 별로 관심이 없다."},
    {n:18, trait:"A", keyed:-1, en:"Insult people.", ko:"사람을 모욕하는 말을 한다."},
    {n:19, trait:"A", keyed:-1, en:"Am not interested in other people's problems.", ko:"남의 고민에 관심이 없다."},
    {n:20, trait:"A", keyed:-1, en:"Feel little concern for others.", ko:"다른 사람에 대한 걱정이 별로 없다."},

    // Conscientiousness (C) — 10 items (6 +, 4 -)
    {n:21, trait:"C", keyed:+1, en:"Am always prepared.", ko:"항상 준비가 되어 있는 편이다."},
    {n:22, trait:"C", keyed:+1, en:"Pay attention to details.", ko:"세부사항에 신경 쓴다."},
    {n:23, trait:"C", keyed:+1, en:"Get chores done right away.", ko:"해야 할 일을 바로 처리한다."},
    {n:24, trait:"C", keyed:+1, en:"Like order.", ko:"정돈된 상태를 좋아한다."},
    {n:25, trait:"C", keyed:+1, en:"Follow a schedule.", ko:"일정/스케줄을 지키는 편이다."},
    {n:26, trait:"C", keyed:+1, en:"Am exacting in my work.", ko:"일을 꼼꼼하고 엄격하게 하는 편이다."},
    {n:27, trait:"C", keyed:-1, en:"Leave my belongings around.", ko:"물건을 아무 데나 두는 편이다."},
    {n:28, trait:"C", keyed:-1, en:"Make a mess of things.", ko:"일/주변을 어질러 놓는다."},
    {n:29, trait:"C", keyed:-1, en:"Often forget to put things back in their proper place.", ko:"물건을 제자리에 두는 걸 자주 잊는다."},
    {n:30, trait:"C", keyed:-1, en:"Shirk my duties.", ko:"해야 할 의무를 회피한다."},

    // Emotional Stability (ES) — 10 items (2 +, 8 -)
    // Note: OCEAN uses Neuroticism (N). We compute ES per IPIP key, then convert to N = 100 - ES.
    {n:31, trait:"ES", keyed:+1, en:"Am relaxed most of the time.", ko:"대체로 긴장을 잘 안 하고 편안한 편이다."},
    {n:32, trait:"ES", keyed:+1, en:"Seldom feel blue.", ko:"우울한 기분을 거의 느끼지 않는다."},
    {n:33, trait:"ES", keyed:-1, en:"Get stressed out easily.", ko:"스트레스를 쉽게 받는다."},
    {n:34, trait:"ES", keyed:-1, en:"Worry about things.", ko:"걱정이 많은 편이다."},
    {n:35, trait:"ES", keyed:-1, en:"Am easily disturbed.", ko:"쉽게 동요한다."},
    {n:36, trait:"ES", keyed:-1, en:"Get upset easily.", ko:"쉽게 속상해한다."},
    {n:37, trait:"ES", keyed:-1, en:"Change my mood a lot.", ko:"기분 변화가 큰 편이다."},
    {n:38, trait:"ES", keyed:-1, en:"Have frequent mood swings.", ko:"감정 기복이 잦다."},
    {n:39, trait:"ES", keyed:-1, en:"Get irritated easily.", ko:"쉽게 짜증이 난다."},
    {n:40, trait:"ES", keyed:-1, en:"Often feel blue.", ko:"우울한 기분을 자주 느낀다."},

    // Intellect/Imagination (O) — 10 items (7 +, 3 -)
    // Often treated as Openness to Experience (O) in OCEAN.
    {n:41, trait:"O", keyed:+1, en:"Have a rich vocabulary.", ko:"어휘가 풍부한 편이다."},
    {n:42, trait:"O", keyed:+1, en:"Have a vivid imagination.", ko:"상상력이 풍부하다."},
    {n:43, trait:"O", keyed:+1, en:"Have excellent ideas.", ko:"좋은 아이디어를 잘 떠올린다."},
    {n:44, trait:"O", keyed:+1, en:"Am quick to understand things.", ko:"이해가 빠른 편이다."},
    {n:45, trait:"O", keyed:+1, en:"Use difficult words.", ko:"어려운 단어를 쓰는 편이다."},
    {n:46, trait:"O", keyed:+1, en:"Spend time reflecting on things.", ko:"무언가를 곱씹어 생각하는 시간을 보낸다."},
    {n:47, trait:"O", keyed:+1, en:"Am full of ideas.", ko:"아이디어가 많은 편이다."},
    {n:48, trait:"O", keyed:-1, en:"Have difficulty understanding abstract ideas.", ko:"추상적인 아이디어를 이해하기 어렵다."},
    {n:49, trait:"O", keyed:-1, en:"Am not interested in abstract ideas.", ko:"추상적인 아이디어에는 흥미가 없다."},
    {n:50, trait:"O", keyed:-1, en:"Do not have a good imagination.", ko:"상상력이 좋은 편은 아니다."},
  ];

  const TRAIT_META = {
    O: {label:"O · 개방성", full:"Openness to Experience (Intellect/Imagination)", alpha:0.84},
    C: {label:"C · 성실성", full:"Conscientiousness", alpha:0.79},
    E: {label:"E · 외향성", full:"Extraversion (Surgency)", alpha:0.87},
    A: {label:"A · 친화성", full:"Agreeableness", alpha:0.82},
    N: {label:"N · 신경성", full:"Neuroticism (inverse of Emotional Stability)", alpha:0.86},
  };

  const OCEAN_ORDER = ["O","C","E","A","N"];

  // -----------------------------
  // State
  // -----------------------------
  const state = {
    startedAt: null,
    itemOrder: [...ITEMS],
    answers: new Map(), // n -> 1..5
    norms: null,
  };

  // -----------------------------
  // DOM helpers
  // -----------------------------
  const $ = (sel) => document.querySelector(sel);
  const el = (tag, cls) => {
    const x = document.createElement(tag);
    if (cls) x.className = cls;
    return x;
  };

  // -----------------------------
  // Rendering questionnaire
  // -----------------------------
  function shuffle(array){
    const a = [...array];
    for (let i = a.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function renderItems(){
    const showEnglish = $("#toggleEnglish").checked;
    const itemsBox = $("#items");
    itemsBox.innerHTML = "";

    state.itemOrder.forEach((it) => {
      const wrap = el("div","item");
      wrap.dataset.n = String(it.n);

      const stem = el("div","stem");
      stem.innerHTML = `<b>${it.n}.</b> ${escapeHtml(it.ko)}` + (showEnglish ? `<small class="mono">${escapeHtml(it.en)}</small>` : "");
      wrap.appendChild(stem);

      const scale = el("div","scale");
      const labelsKo = ["매우 아니다","약간 아니다","중간","약간 그렇다","매우 그렇다"];
      for(let v=1; v<=5; v++){
        const opt = el("label","opt");
        opt.innerHTML = `<input type="radio" name="q${it.n}" value="${v}" /> <span>${v}<br/><span class="muted">${labelsKo[v-1]}</span></span>`;
        opt.addEventListener("click", () => {
          // Radio can be clicked on label; set value explicitly
          state.answers.set(it.n, v);
          updateSelected(it.n);
          updateProgress();
        });
        scale.appendChild(opt);
      }
      wrap.appendChild(scale);
      itemsBox.appendChild(wrap);
      updateSelected(it.n);
    });

    updateProgress();
  }

  function updateSelected(n){
    const container = document.querySelector(`.item[data-n="${n}"]`);
    if (!container) return;
    const selected = state.answers.get(Number(n));
    const opts = container.querySelectorAll(".opt");
    opts.forEach((o) => o.classList.remove("selected"));
    if (selected){
      const idx = selected - 1;
      if (opts[idx]) opts[idx].classList.add("selected");
      const input = container.querySelector(`input[value="${selected}"]`);
      if (input) input.checked = true;
    } else {
      const inputs = container.querySelectorAll("input");
      inputs.forEach(i => i.checked = false);
    }
  }

  function updateProgress(){
    const total = ITEMS.length;
    const answered = state.answers.size;
    const pct = Math.round((answered/total)*100);
    $("#progressText").textContent = `${answered} / ${total} (${pct}%)`;
    $("#progressBar").style.width = pct + "%";
  }

  // -----------------------------
  // Scoring
  // -----------------------------
  function reverseLikert(v){ return 6 - v; }

  function scoreTrait(traitCode){
    const items = ITEMS.filter(it => it.trait === traitCode);
    let sum = 0;
    let count = 0;
    const detail = [];
    for (const it of items){
      const raw = state.answers.get(it.n);
      if (!raw) continue;
      let scored = raw;
      if (it.keyed === -1) scored = reverseLikert(raw);
      sum += scored;
      count += 1;
      detail.push({n: it.n, raw, scored, keyed: it.keyed, trait: traitCode, text: it.ko, en: it.en});
    }
    const mean = count ? (sum / count) : null; // 1..5
    const scaled = mean !== null ? ((mean - 1) / 4) * 100 : null; // 0..100
    return {sum, count, mean, scaled, detail};
  }

  function scoreAll(){
    const E = scoreTrait("E");
    const A = scoreTrait("A");
    const C = scoreTrait("C");
    const ES = scoreTrait("ES");
    const O = scoreTrait("O");

    // Convert ES -> N (Neuroticism): inverse linear mapping
    const N = {
      sum: ES.count ? (ES.count * (6 - ES.mean)) : null,
      count: ES.count,
      mean: ES.mean !== null ? (6 - ES.mean) : null,
      scaled: ES.scaled !== null ? (100 - ES.scaled) : null,
      detail: ES.detail.map(d => ({
        ...d,
        trait: "N",
        // For transparency, show "scored for ES" and then for N we invert
        scoredN: d.scored !== null ? (6 - d.scored) : null,
      })),
      _fromES: ES
    };

    return {O,C,E,A,N, ES};
  }

  function bandFromScaled(x){
    if (x === null) return {key:"na", label:"(미응답)"};
    if (x < 30) return {key:"low", label:"낮음(낮은 편)"};
    if (x < 45) return {key:"somewhat_low", label:"다소 낮음"};
    if (x <= 55) return {key:"mid", label:"중간(균형)"};
    if (x <= 70) return {key:"somewhat_high", label:"다소 높음"};
    return {key:"high", label:"높음(높은 편)"};
  }

  // -----------------------------
  // Interpretation text
  // (Designed to be academically grounded but readable)
  // -----------------------------
  function interpText(trait, scaled){
    const b = bandFromScaled(scaled).key;

    const common = {
      O: {
        title: "개방성 O (Openness) — 호기심·상상력·새로움 수용",
        subtitle: "‘새로운 것’에 대한 선호, 아이디어/미학/추상 개념에 대한 개방성",
        high: [
          "새로운 경험/아이디어를 탐색하는 걸 즐기고, 다양한 관점의 가능성을 열어두는 경향이 큽니다.",
          "예술/문화/지적 자극에 끌릴 수 있고, 익숙한 방식보다 ‘다른 방식’을 실험하는 데 편합니다.",
          "환경이 허용하면 학습·창의·전략 사고에서 강점이 나올 수 있습니다."
        ],
        low: [
          "익숙하고 검증된 방식이 편하고, 지나치게 추상적인 얘기보다는 ‘현실적으로 뭐가 되냐’를 중시할 수 있습니다.",
          "새로움 자체를 싫어한다기보다는, 변화 비용 대비 효용을 따져 안정적인 선택을 선호하는 쪽에 가깝습니다.",
          "실무/운영/루틴 최적화에서 강점이 될 수 있습니다."
        ],
        mid: [
          "새로운 것과 익숙한 것 사이에서 균형을 잡는 편입니다.",
          "상황에 따라 탐색(새로움)과 실행(검증된 방식)을 적절히 오갈 가능성이 큽니다."
        ],
        pitfallsHigh: [
          "아이디어는 많은데 실행(일정/정리)이 약하면 ‘생각만 많고 끝이 없음’으로 보일 수 있습니다.",
          "새로움에 치우치면 루틴 유지/반복 숙련이 지루하게 느껴질 수 있습니다."
        ],
        pitfallsLow: [
          "변화가 필요한 상황에서도 ‘늘 하던 방식’에 머물면 적응이 느려질 수 있습니다.",
          "새로운 관점의 장점을 과소평가할 가능성이 있습니다."
        ],
        microQA: [
          ["그럼 이건 뭐야?","‘개방성 높음 = 똑똑함’ 아니냐?"], 
          ["답","아니. 개방성은 IQ랑 동일 개념이 아닙니다. ‘호기심/상상/추상 선호’ 쪽에 더 가깝고, 지능은 별도의 능력 영역입니다."]
        ],
      },
      C: {
        title: "성실성 C (Conscientiousness) — 계획·자기통제·책임감",
        subtitle: "목표를 세우고 꾸준히 지키는 경향, 조직화/주의 깊음/자기조절",
        high: [
          "일을 계획하고 정리해서 ‘끝까지’ 가져가는 힘이 큽니다.",
          "마감·품질·규칙을 중시하고, 실수 줄이기/체크리스트 운용에 강할 수 있습니다.",
          "학업/업무 성과와 관련이 자주 보고되는 요인입니다."
        ],
        low: [
          "즉흥적·유연한 편이라 ‘상황 변화’에 빠르게 반응할 수 있습니다.",
          "다만 계획/정리/마감 관리가 약해지면 결과가 들쑥날쑥해질 수 있습니다.",
          "루틴이 강하게 필요한 환경에서는 피로가 쌓이기 쉽습니다."
        ],
        mid: [
          "필요할 때는 계획을 세우되, 과도하게 경직되지는 않는 균형형일 가능성이 큽니다.",
          "정리/즉흥을 상황에 맞춰 조절하는 편입니다."
        ],
        pitfallsHigh: [
          "완벽주의/과통제 쪽으로 기울면 ‘조금만 틀어져도 불편’해질 수 있습니다.",
          "타인에게도 같은 기준을 요구하면 갈등이 생길 수 있습니다."
        ],
        pitfallsLow: [
          "‘내일의 나’에게 일을 떠넘기는 패턴이 반복될 수 있습니다.",
          "중요 과제가 누락/지연되면 스트레스(또는 자책)가 커질 수 있습니다."
        ],
        microQA: [
          ["그럼 이건 뭐야?","‘성실성 낮음 = 게으름’임?"], 
          ["답","딱 그렇게 단정하면 사고 난다. 낮음은 ‘자기구조화/계획성’이 약한 경향일 뿐, 창의·유연·즉흥성으로 장점이 될 수도 있어요. 다만 환경이 계획을 요구하면 불리해질 수 있습니다."]
        ],
      },
      E: {
        title: "외향성 E (Extraversion) — 에너지의 방향(대인/활동성)",
        subtitle: "사교성, 활력, 자기표현/주도성, 긍정 정서 경험 경향",
        high: [
          "사람/활동에서 에너지를 얻는 편이고, 대화 시작·네트워킹이 자연스러울 수 있습니다.",
          "자기표현/주도성(때로는 리더십)이 드러나기 쉽고, 분위기를 띄우는 역할을 맡기도 합니다."
        ],
        low: [
          "조용하고 내향적인 편이라 혼자 있거나 소수의 깊은 관계에서 편안함을 느낄 수 있습니다.",
          "‘말이 적다’가 곧 ‘사회성이 없다’는 뜻은 아닙니다. 에너지 충전 방식이 다른 겁니다."
        ],
        mid: [
          "필요할 때는 나서고, 필요할 때는 물러나는 ‘스위치형’일 수 있습니다.",
          "상황과 사람에 따라 외향/내향이 조절되는 편입니다."
        ],
        pitfallsHigh: [
          "자극/사람 일정이 과하면 번아웃이 올 수 있고, 깊이 생각할 시간 확보가 어려워질 수 있습니다.",
          "말이 빠르면 ‘경청’이 약해 보일 수 있습니다."
        ],
        pitfallsLow: [
          "의견을 말할 기회를 스스로 놓치면 과소평가될 수 있습니다.",
          "낯선 환경에서는 적응에 시간이 더 걸릴 수 있습니다."
        ],
        microQA: [
          ["그럼 이건 뭐야?","내향적이면 ‘낯가림/수줍음’이랑 같은 거냐?"], 
          ["답","같은 게 아닙니다. 내향성은 에너지 방향(혼자/소수에서 충전)에 가깝고, 수줍음은 평가 불안/긴장과 더 관련이 있습니다."]
        ],
      },
      A: {
        title: "친화성 A (Agreeableness) — 배려·협력·신뢰",
        subtitle: "타인에 대한 따뜻함/공감/협력 성향 vs. 경쟁/단호/회의",
        high: [
          "타인의 감정과 필요를 잘 고려하고, 협력/조율에서 강점이 나올 수 있습니다.",
          "갈등을 완화하고 관계를 유지하는 데 유리하며, ‘사람을 편하게 하는’ 역할을 자주 합니다."
        ],
        low: [
          "단호하고 비판적 사고가 강해 ‘원칙/성과/진실’에 집중할 수 있습니다.",
          "협상/경쟁 환경에서 유리하게 작동하기도 하지만, 말투가 거칠면 오해를 살 수 있습니다."
        ],
        mid: [
          "상대 배려와 자기 주장 사이 균형을 잡는 편일 수 있습니다.",
          "협력도 하되, 필요하면 선을 긋는 스타일일 가능성이 큽니다."
        ],
        pitfallsHigh: [
          "거절을 못 하거나, 과하게 맞춰주다가 소진될 수 있습니다.",
          "갈등 회피가 누적되면 폭발하거나 관계가 비틀릴 수 있습니다."
        ],
        pitfallsLow: [
          "솔직함이 ‘공격성’으로 읽히면 대인 비용이 커질 수 있습니다.",
          "타인의 감정 신호를 놓치면 불필요한 마찰이 생길 수 있습니다."
        ],
        microQA: [
          ["그럼 이건 뭐야?","친화성 높으면 ‘착한 사람’이고 낮으면 ‘나쁜 사람’임?"], 
          ["답","그렇게 도덕 점수로 보면 망합니다. 친화성은 ‘협력/공감 경향’이지 선악이 아니고, 낮은 친화성도 상황에 따라 필요한 ‘단호함’으로 작동할 수 있습니다."]
        ],
      },
      N: {
        title: "신경성 N (Neuroticism) — 정서적 반응성/스트레스 민감도",
        subtitle: "불안/걱정/기분 흔들림 같은 부정 정서를 경험하는 경향(정서 안정의 반대)",
        high: [
          "스트레스 신호에 민감해서 위험을 빨리 감지하고 대비하는 면이 있을 수 있습니다.",
          "다만 걱정·긴장·기분 기복이 잦아지면 에너지가 많이 소모될 수 있습니다.",
          "압박이 큰 환경에서는 회복/휴식 루틴이 특히 중요해집니다."
        ],
        low: [
          "정서적으로 비교적 안정적이고, 스트레스 상황에서도 침착함을 유지하기 쉽습니다.",
          "감정 기복이 적어 ‘멘탈이 단단하다’는 평가를 받을 수 있습니다."
        ],
        mid: [
          "상황에 따라 적당히 긴장하고 적당히 회복하는 균형형일 가능성이 큽니다.",
          "스트레스에 완전 무감각도 아니고, 과도하게 흔들리지도 않는 편입니다."
        ],
        pitfallsHigh: [
          "부정적 감정이 오래 지속되면 회피/미루기/과잉확인 같은 패턴이 생길 수 있습니다.",
          "자기비난 루프가 길어지면 기능(수면/집중/관계)에 영향이 갈 수 있습니다."
        ],
        pitfallsLow: [
          "위험 신호를 과소평가하거나, 지나치게 무던해서 문제를 늦게 알아차릴 수도 있습니다."
        ],
        microQA: [
          ["그럼 이건 뭐야?","신경성 높으면 ‘불안장애’임?"], 
          ["답","아니. 성격 특질 점수는 진단이 아닙니다. 다만 높은 신경성이 스트레스 경험과 관련될 수 있다는 연구는 많아서, 생활 기능에 문제가 생기면 전문가 상담이 도움될 수 있습니다."]
        ],
      }
    };

    const t = common[trait];
    const chosen = (b === "high" || b === "somewhat_high") ? "high"
                  : (b === "low" || b === "somewhat_low") ? "low"
                  : "mid";

    const bulletsMain = t[chosen];
    const pitfalls = (chosen === "high") ? t.pitfallsHigh : (chosen === "low" ? t.pitfallsLow : []);
    const qa = t.microQA || [];

    return { ...t, chosen, bulletsMain, pitfalls, qa, bandLabel: bandFromScaled(scaled).label };
  }

  // -----------------------------
  // Validity checks (lightweight heuristics)
  // -----------------------------
  function validityChecks(){
    const total = ITEMS.length;
    const answered = state.answers.size;

    const warnings = [];
    const notes = [];

    // Missing
    if (answered < total){
      warnings.push(`미응답 ${total - answered}개가 있습니다. (가능하면 전부 답하는 게 안정적입니다.)`);
    }

    // Straightlining (all answers identical)
    if (answered === total){
      const vals = Array.from(state.answers.values());
      const uniq = new Set(vals);
      if (uniq.size === 1){
        warnings.push("모든 문항을 같은 값으로 선택했습니다(일명 straightlining). 실제 성향을 반영했는지 한 번 점검해보세요.");
      }
      // Extreme responding
      const extreme = vals.filter(v => v === 1 || v === 5).length;
      if (extreme / total >= 0.75){
        notes.push("극단 응답(1/5) 비율이 높습니다. 성향이 뚜렷할 수도 있지만, ‘중간 값 회피’ 습관일 수도 있습니다.");
      }
    }

    // Speed check
    if (state.startedAt){
      const secs = Math.max(1, (Date.now() - state.startedAt)/1000);
      const secPerItem = secs / Math.max(1, answered);
      if (answered >= 20 && secPerItem < 2.0){
        warnings.push(`응답 속도가 꽤 빠른 편입니다(약 ${secPerItem.toFixed(1)}초/문항). 빨리 찍었다면 신뢰도가 떨어질 수 있습니다.`);
      } else {
        notes.push(`응답 속도: 약 ${secPerItem.toFixed(1)}초/문항`);
      }
    }

    return {warnings, notes};
  }

  // -----------------------------
  // Radar chart (Canvas)
  // -----------------------------
  function drawRadar(scores){
    const canvas = $("#radar");
    const ctx = canvas.getContext("2d");
    const w = canvas.width, h = canvas.height;

    ctx.clearRect(0,0,w,h);

    const cx = w/2, cy = h/2 + 10;
    const radius = Math.min(w, h) * 0.33;

    const labels = OCEAN_ORDER.map(k => TRAIT_META[k].label.split(" · ")[0]);
    const fullLabels = OCEAN_ORDER.map(k => TRAIT_META[k].label);
    const values = OCEAN_ORDER.map(k => scores[k].scaled);

    // background grid
    ctx.save();
    ctx.translate(cx, cy);

    // grid circles (polygons)
    const levels = [20,40,60,80,100];
    const angles = labels.map((_,i)=> (Math.PI*2*i/labels.length) - Math.PI/2);

    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(156,163,175,.22)";
    ctx.fillStyle = "rgba(17,24,39,.35)";

    levels.forEach((lv, idx)=>{
      const r = radius * (lv/100);
      ctx.beginPath();
      angles.forEach((a,j)=>{
        const x = r*Math.cos(a);
        const y = r*Math.sin(a);
        if (j===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.closePath();
      ctx.stroke();
      if (idx===0){
        ctx.fill();
      }
    });

    // axes
    ctx.strokeStyle = "rgba(96,165,250,.25)";
    angles.forEach((a)=>{
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.lineTo(radius*Math.cos(a), radius*Math.sin(a));
      ctx.stroke();
    });

    // labels
    ctx.fillStyle = "rgba(229,231,235,.95)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans KR', Arial, sans-serif";
    angles.forEach((a,i)=>{
      const r = radius + 18;
      const x = r*Math.cos(a);
      const y = r*Math.sin(a);
      ctx.textAlign = (Math.cos(a) > 0.25) ? "left" : (Math.cos(a) < -0.25 ? "right" : "center");
      ctx.textBaseline = (Math.sin(a) > 0.25) ? "top" : (Math.sin(a) < -0.25 ? "bottom" : "middle");
      ctx.fillText(fullLabels[i], x, y);
    });

    // data polygon
    ctx.strokeStyle = "rgba(96,165,250,.85)";
    ctx.fillStyle = "rgba(96,165,250,.18)";
    ctx.lineWidth = 2;

    ctx.beginPath();
    angles.forEach((a,i)=>{
      const v = clamp(values[i] ?? 0, 0, 100);
      const r = radius * (v/100);
      const x = r*Math.cos(a);
      const y = r*Math.sin(a);
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // points
    ctx.fillStyle = "rgba(52,211,153,.95)";
    angles.forEach((a,i)=>{
      const v = clamp(values[i] ?? 0, 0, 100);
      const r = radius * (v/100);
      const x = r*Math.cos(a);
      const y = r*Math.sin(a);
      ctx.beginPath();
      ctx.arc(x,y,4,0,Math.PI*2);
      ctx.fill();
    });

    // title
    ctx.fillStyle = "rgba(229,231,235,.95)";
    ctx.font = "700 13px system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans KR', Arial, sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("OCEAN 스펙트럼 (0–100)", 0, -radius - 36);

    ctx.restore();
  }

  function renderBars(scores){
    const box = $("#bars");
    box.innerHTML = "";
    OCEAN_ORDER.forEach(code=>{
      const meta = TRAIT_META[code];
      const val = scores[code].scaled ?? 0;
      const row = el("div","scoreCard");
      row.innerHTML = `
        <div class="t">${escapeHtml(meta.label)} <span class="muted">· α≈${meta.alpha.toFixed(2)}</span></div>
        <div class="v">${fmt(val)}<span class="tiny muted">/100</span></div>
        <div class="s">평균 ${fmt(scores[code].mean)} / 5 · 합계 ${fmt(scores[code].sum)} (응답 ${scores[code].count}/10)</div>
        <div class="hbar" aria-hidden="true"><div style="width:${clamp(val,0,100)}%"></div></div>
      `;
      box.appendChild(row);
    });
  }

  function renderScoreCards(scores){
    const box = $("#scoreCards");
    box.innerHTML = "";
    OCEAN_ORDER.forEach(code=>{
      const meta = TRAIT_META[code];
      const v = scores[code].scaled;
      const b = bandFromScaled(v).label;
      const c = el("div","scoreCard");
      c.innerHTML = `
        <div class="t">${escapeHtml(meta.label)}</div>
        <p class="v">${fmt(v)}<span class="tiny muted">/100</span></p>
        <div class="s">${escapeHtml(b)}</div>
      `;
      box.appendChild(c);
    });
  }

  function renderInterpretations(scores){
    const map = {O:"#interpO", C:"#interpC", E:"#interpE", A:"#interpA", N:"#interpN"};
    OCEAN_ORDER.forEach(code=>{
      const t = interpText(code, scores[code].scaled);
      const det = $(map[code]);
      det.innerHTML = "";

      const sum = el("summary");
      sum.innerHTML = `${escapeHtml(t.title)} <small>· ${escapeHtml(t.bandLabel)}</small>`;
      det.appendChild(sum);

      const p0 = el("p","tiny muted");
      p0.textContent = t.subtitle;
      det.appendChild(p0);

      const ul = el("ul","tiny");
      t.bulletsMain.forEach(x=>{
        const li = el("li");
        li.textContent = x;
        ul.appendChild(li);
      });
      det.appendChild(ul);

      if (t.pitfalls && t.pitfalls.length){
        const p1 = el("p","tiny");
        p1.innerHTML = `<b>주의 포인트(과해지면 생기는 부작용):</b>`;
        det.appendChild(p1);
        const ul2 = el("ul","tiny");
        t.pitfalls.forEach(x=>{
          const li = el("li");
          li.textContent = x;
          ul2.appendChild(li);
        });
        det.appendChild(ul2);
      }

      if (t.qa && t.qa.length){
        const qaBox = el("div","note tiny");
        qaBox.innerHTML = `<b>${escapeHtml(t.qa[0][0])}</b><br/>${escapeHtml(t.qa[0][1])}<br/><br/><b>${escapeHtml(t.qa[1][0])}</b><br/>${escapeHtml(t.qa[1][1])}`;
        det.appendChild(qaBox);
      }

      const p2 = el("p","tiny muted");
      p2.innerHTML = `이 해석은 성격 특질 연구의 일반적 정의를 바탕으로 한 <b>설명 프레임</b>입니다. 상황/역할/문화에 따라 표현은 달라질 수 있습니다.`;
      det.appendChild(p2);
    });
  }

  function renderValidity(){
    const {warnings, notes} = validityChecks();
    const box = $("#validity");
    box.innerHTML = "";

    if (warnings.length){
      const w = el("div","warnBox tiny");
      w.innerHTML = `<b>응답 품질 체크(주의)</b><ul>${warnings.map(x=>`<li>${escapeHtml(x)}</li>`).join("")}</ul>`;
      box.appendChild(w);
    }
    if (notes.length){
      const n = el("div","okBox tiny");
      n.innerHTML = `<b>참고</b><ul>${notes.map(x=>`<li>${escapeHtml(x)}</li>`).join("")}</ul>`;
      box.appendChild(n);
    }
  }

  function renderScoreTable(scores){
    // For transparency, we show "trait as OCEAN", so ES items will be shown under N.
    const rows = [];

    const lookup = new Map();
    ITEMS.forEach(it => lookup.set(it.n, it));

    // We want to show in original item numbering order 1..50
    for (let n=1; n<=50; n++){
      const it = lookup.get(n);
      const raw = state.answers.get(n) ?? null;

      // scored for its original factor (E/A/C/ES/O)
      let scored = raw;
      if (raw !== null){
        scored = (it.keyed === -1) ? reverseLikert(raw) : raw;
      }

      // Display trait label: ES items are shown as N because OCEAN
      const traitLabel = (it.trait === "ES") ? "N · 신경성(ES 역변환)" : `${it.trait} · ${traitNameKo(it.trait)}`;

      // For N: "반전 후" means N-scored value (invert ES score)
      let scoredDisplay = scored;
      if (it.trait === "ES" && raw !== null){
        scoredDisplay = 6 - scored; // N scoring
      }

      rows.push({
        n,
        traitLabel,
        text: it.ko,
        raw,
        scored: scoredDisplay,
      });
    }

    const tbody = $("#scoreTableBody");
    tbody.innerHTML = rows.map(r => `
      <tr>
        <td class="mono">${r.n}</td>
        <td>${escapeHtml(r.traitLabel)}</td>
        <td>${escapeHtml(r.text)}</td>
        <td class="mono">${r.raw === null ? "-" : r.raw}</td>
        <td class="mono">${r.raw === null ? "-" : r.scored}</td>
      </tr>
    `).join("");
  }

  function traitNameKo(code){
    if (code==="O") return "개방성";
    if (code==="C") return "성실성";
    if (code==="E") return "외향성";
    if (code==="A") return "친화성";
    if (code==="ES") return "정서 안정성";
    return code;
  }

  // -----------------------------
  // Norms (optional)
  // -----------------------------
  function renderNormInputs(){
    const box = $("#normInputs");
    box.innerHTML = "";
    OCEAN_ORDER.forEach(code=>{
      const meta = TRAIT_META[code];
      const block = el("div","kv");
      block.innerHTML = `
        <b>${escapeHtml(meta.label)}</b>
        <div class="field">
          <label>평균(0~100 스케일)</label>
          <input type="number" step="0.01" min="0" max="100" id="normMean_${code}" placeholder="예: 52.3" />
        </div>
        <div class="field">
          <label>표준편차 SD(0~100 스케일)</label>
          <input type="number" step="0.01" min="0.01" max="50" id="normSd_${code}" placeholder="예: 12.7" />
        </div>
      `;
      box.appendChild(block);
    });
  }

  function applyNorms(scores){
    const norms = {};
    for (const code of OCEAN_ORDER){
      const m = parseFloat($("#normMean_"+code).value);
      const sd = parseFloat($("#normSd_"+code).value);
      if (!isFinite(m) || !isFinite(sd) || sd <= 0) return null;
      norms[code] = {mean:m, sd:sd};
    }
    const out = {};
    for (const code of OCEAN_ORDER){
      const x = scores[code].scaled;
      const {mean, sd} = norms[code];
      const z = (x - mean) / sd;
      const pct = 100 * 0.5 * (1 + erf(z / Math.SQRT2));
      out[code] = {z, pct};
    }
    state.norms = norms;
    return out;
  }

  function clearNorms(){
    OCEAN_ORDER.forEach(code=>{
      $("#normMean_"+code).value = "";
      $("#normSd_"+code).value = "";
    });
    $("#normOut").innerHTML = "";
    state.norms = null;
  }

  // Error function approximation
  function erf(x){
    // Abramowitz and Stegun approximation
    const sign = Math.sign(x);
    x = Math.abs(x);
    const a1 =  0.254829592;
    const a2 = -0.284496736;
    const a3 =  1.421413741;
    const a4 = -1.453152027;
    const a5 =  1.061405429;
    const p  =  0.3275911;
    const t = 1.0/(1.0 + p*x);
    const y = 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-x*x);
    return sign*y;
  }

  // -----------------------------
  // Export
  // -----------------------------
  function buildResultPayload(scores){
    const now = new Date();
    const payload = {
      version: "ipip50-ocean-singlefile-1.0",
      generatedAt: now.toISOString(),
      scoring: {
        scale: "IPIP Big-Five Factor Markers (50-item; 10 items per factor)",
        likert: {min:1, max:5, anchors_ko:["매우 아니다","약간 아니다","중간","약간 그렇다","매우 그렇다"]},
        reverse: "reverse-coded items scored as (6 - response) per IPIP scoring instructions; Neuroticism is inverse of IPIP Emotional Stability.",
      },
      scores: {},
      answeredCount: state.answers.size,
      responseSeconds: state.startedAt ? (Date.now() - state.startedAt)/1000 : null
    };
    OCEAN_ORDER.forEach(code=>{
      payload.scores[code] = {
        label: TRAIT_META[code].label,
        mean_1to5: scores[code].mean,
        scaled_0to100: scores[code].scaled,
        sum: scores[code].sum,
        itemsAnswered: scores[code].count
      };
    });
    return payload;
  }

  function downloadText(filename, text){
    const blob = new Blob([text], {type:"application/json;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = el("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function downloadCanvasPng(canvas, filename){
    canvas.toBlob((blob)=>{
      const url = URL.createObjectURL(blob);
      const a = el("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });
  }

  async function copyToClipboard(text){
    try{
      await navigator.clipboard.writeText(text);
      alert("복사 완료");
    }catch(e){
      // fallback
      const ta = el("textarea");
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
      alert("복사 완료(폴백)");
    }
  }

  // -----------------------------
  // Events
  // -----------------------------
  function ensureStarted(){
    if (!state.startedAt) state.startedAt = Date.now();
  }

  $("#toggleEnglish").addEventListener("change", () => renderItems());

  $("#shuffleItems").addEventListener("change", () => {
    state.itemOrder = $("#shuffleItems").checked ? shuffle(ITEMS) : [...ITEMS];
    renderItems();
  });

  $("#btnReset").addEventListener("click", () => {
    if (!confirm("전체 응답을 초기화할까요?")) return;
    state.answers.clear();
    state.startedAt = null;
    renderItems();
    $("#results").classList.add("hidden");
    window.scrollTo({top:0, behavior:"smooth"});
  });

  $("#btnScore").addEventListener("click", () => {
    ensureStarted();
    const requireAll = $("#requireAll").checked;
    if (requireAll && state.answers.size < ITEMS.length){
      alert("미응답 문항이 있습니다. (설정에서 ‘미응답 있으면 결과 계산 막기’를 해제할 수도 있어요.)");
      return;
    }
    const scoresAll = scoreAll();
    const scores = {O:scoresAll.O, C:scoresAll.C, E:scoresAll.E, A:scoresAll.A, N:scoresAll.N};

    // Render results
    $("#results").classList.remove("hidden");
    renderScoreCards(scores);
    drawRadar(scores);
    renderBars(scores);
    renderInterpretations(scores);
    renderValidity();
    renderScoreTable(scoresAll);

    // time info
    const secs = state.startedAt ? Math.round((Date.now() - state.startedAt)/1000) : null;
    $("#timeInfo").textContent = secs ? `응답 시간: 약 ${secs}초` : "";

    // Norm inputs
    renderNormInputs();
    $("#normOut").innerHTML = "";

    // Scroll to results
    $("#results").scrollIntoView({behavior:"smooth", block:"start"});

    // Wire export buttons (once per score)
    const payload = buildResultPayload(scores);
    $("#btnDownloadJson").onclick = () => downloadText("big5_ipip50_result.json", JSON.stringify(payload, null, 2));
    $("#btnCopyJson").onclick = () => copyToClipboard(JSON.stringify(payload, null, 2));
    $("#btnDownloadPng").onclick = () => downloadCanvasPng($("#radar"), "big5_ocean_radar.png");

    $("#btnApplyNorms").onclick = () => {
      const out = applyNorms(scores);
      if (!out){
        $("#normOut").innerHTML = `<div class="warnBox"><b>입력 확인</b><div class="tiny">모든 요인에 평균과 SD를 숫자로 입력해야 z/백분위를 계산할 수 있습니다.</div></div>`;
        return;
      }
      const lines = OCEAN_ORDER.map(code=>{
        const meta = TRAIT_META[code];
        return `<li><b>${escapeHtml(meta.label)}</b>: z=${out[code].z.toFixed(2)}, 백분위≈${out[code].pct.toFixed(1)}%</li>`;
      }).join("");
      $("#normOut").innerHTML = `<div class="okBox"><b>표준화 결과(정규분포 가정)</b><ul class="tiny">${lines}</ul></div>`;
    };

    $("#btnClearNorms").onclick = () => clearNorms();
  });

  // Start timer on first interaction with questionnaire
  document.addEventListener("click", (e)=>{
    const inItem = e.target.closest(".item");
    if (inItem) ensureStarted();
  }, {passive:true});

  // Initial render
  renderItems();
  renderNormInputs();

  // -----------------------------
  // Utils
  // -----------------------------
  function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
  function fmt(x){
    if (x === null || x === undefined || !isFinite(x)) return "-";
    return (Math.round(x*10)/10).toFixed(1);
  }
  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

})();
</script>
</body>
</html>
